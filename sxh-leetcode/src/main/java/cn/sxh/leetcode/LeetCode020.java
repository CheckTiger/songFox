package cn.sxh.leetcode;

/**
 * 题目：整数反转
 * <p>
 * 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
 * <p>
 * 如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。
 * <p>
 * 假设环境不允许存储 64 位整数（有符号或无符号）。
 */
public class LeetCode020 {


    //解题思路
    //1.整数变成字符串，再去反转这个字符串？
    //这两种方式是可以，但并不好。实际上我们只要能拿到这个整数的 末尾数字 就可以了。
    //以12345为例，先拿到5，再拿到4，之后是3，2，1，我们按这样的顺序就可以反向拼接处一个数字了，也就能达到 反转 的效果。
    //怎么拿末尾数字呢？好办，用取模运算就可以了
    //1、将12345 % 10 得到5，之后将12345 / 10
    //2、将1234 % 10 得到4，再将1234 / 10
    //3、将123 % 10 得到3，再将123 / 10
    //4、将12 % 10 得到2，再将12 / 10
    //5、将1 % 10 得到1，再将1 / 10
    //这么看起来，一个循环就搞定了，循环的判断条件是x>0
    //但这样不对，因为忽略了 负数
    //循环的判断条件应该是while(x!=0)，无论正数还是负数，按照上面不断的/10这样的操作，最后都会变成0，所以判断终止条件就是!=0
    //有了取模和除法操作，对于像12300这样的数字，也可以完美的解决掉了。
    //看起来这道题就这么解决了，但请注意，题目上还有这么一句
    //假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。
    //也就是说我们不能用long存储最终结果，而且有些数字可能是合法范围内的数字，但是反转过来就超过范围了。
    //假设有1147483649这个数字，它是小于最大的32位整数2147483647的，但是将这个数字反转过来后就变成了9463847411，这就比最大的32位整数还要大了，这样的数字是没法存到int里面的，所以肯定要返回0(溢出了)。

    public static void main(String[] args) {
        int reverse = reverse(2147483647);
        System.out.println(reverse);
    }

    public static int reverse(int x) {
        int res = 0;
        while (x != 0) {
            int temp = x % 10;
            if (res > 214748364 || (res == 214748364 && temp > 7)) {
                return 0;
            }

            if (res < -214748364 || (res == -214748364 && temp < -8)) {
                return 0;
            }
            res = res * 10 + temp;
            x /= 10;
        }
        return res;
    }

}
